# -*- coding: utf-8 -*-
"""stock_predictor.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tJSmg-06sEJ_Ia3_KCAAotoDmliVrz-q
"""

import streamlit as st
import pandas as pd
import numpy as np
import yfinance as yf
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
import warnings
from tenacity import retry, stop_after_attempt, wait_exponential, retry_if_exception_type
import time
import io
warnings.filterwarnings('ignore')

# Set page config
st.set_page_config(
    page_title="Indian Stock Price Predictor",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 10px;
        border-left: 5px solid #1f77b4;
    }
    .prediction-box {
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 1.5rem;
        border-radius: 15px;
        text-align: center;
        margin: 1rem 0;
    }
    .stSelectbox > div > div > div {
        background-color: #f0f2f6;
    }
</style>
""", unsafe_allow_html=True)

# Indian Stock Market Tickers
@st.cache_data
def get_indian_stock_tickers():
    """Get comprehensive list of Indian stock tickers"""

    # Major Indian stocks with their sectors
    indian_stocks = {
        # Banking & Financial Services
        'HDFCBANK.NS': 'HDFC Bank - Banking',
        'ICICIBANK.NS': 'ICICI Bank - Banking',
        'SBIN.NS': 'State Bank of India - Banking',
        'KOTAKBANK.NS': 'Kotak Mahindra Bank - Banking',
        'AXISBANK.NS': 'Axis Bank - Banking',
        'INDUSINDBK.NS': 'IndusInd Bank - Banking',
        'BANKBARODA.NS': 'Bank of Baroda - Banking',
        'PNB.NS': 'Punjab National Bank - Banking',
        'FEDERALBNK.NS': 'Federal Bank - Banking',
        'IDFCFIRSTB.NS': 'IDFC First Bank - Banking',

        # IT Services
        'TCS.NS': 'Tata Consultancy Services - IT',
        'INFY.NS': 'Infosys - IT',
        'WIPRO.NS': 'Wipro - IT',
        'HCLTECH.NS': 'HCL Technologies - IT',
        'TECHM.NS': 'Tech Mahindra - IT',
        'LTI.NS': 'L&T Infotech - IT',
        'MPHASIS.NS': 'Mphasis - IT',
        'MINDTREE.NS': 'Mindtree - IT',

        # Oil & Gas
        'RELIANCE.NS': 'Reliance Industries - Oil & Gas',
        'ONGC.NS': 'Oil & Natural Gas Corporation - Oil & Gas',
        'IOC.NS': 'Indian Oil Corporation - Oil & Gas',
        'BPCL.NS': 'Bharat Petroleum - Oil & Gas',
        'HINDPETRO.NS': 'Hindustan Petroleum - Oil & Gas',
        'GAIL.NS': 'GAIL India - Oil & Gas',

        # Automobiles
        'MARUTI.NS': 'Maruti Suzuki - Automobiles',
        'TATAMOTORS.NS': 'Tata Motors - Automobiles',
        'M&M.NS': 'Mahindra & Mahindra - Automobiles',
        'BAJAJ-AUTO.NS': 'Bajaj Auto - Automobiles',
        'HEROMOTOCO.NS': 'Hero MotoCorp - Automobiles',
        'TVSMOTORS.NS': 'TVS Motor Company - Automobiles',
        'EICHERMOT.NS': 'Eicher Motors - Automobiles',
        'ASHOKLEY.NS': 'Ashok Leyland - Automobiles',

        # Metals & Mining
        'TATASTEEL.NS': 'Tata Steel - Metals',
        'JSWSTEEL.NS': 'JSW Steel - Metals',
        'HINDALCO.NS': 'Hindalco Industries - Metals',
        'SAIL.NS': 'SAIL - Metals',
        'VEDL.NS': 'Vedanta - Metals',
        'COALINDIA.NS': 'Coal India - Mining',
        'NMDC.NS': 'NMDC - Mining',

        # Pharmaceuticals
        'SUNPHARMA.NS': 'Sun Pharmaceutical - Pharma',
        'DRREDDY.NS': 'Dr. Reddys Laboratories - Pharma',
        'CIPLA.NS': 'Cipla - Pharma',
        'DIVISLAB.NS': 'Divis Laboratories - Pharma',
        'BIOCON.NS': 'Biocon - Pharma',
        'LUPIN.NS': 'Lupin - Pharma',
        'AUROPHARMA.NS': 'Aurobindo Pharma - Pharma',
        'TORNTPHARM.NS': 'Torrent Pharmaceuticals - Pharma',

        # FMCG
        'HINDUNILVR.NS': 'Hindustan Unilever - FMCG',
        'ITC.NS': 'ITC - FMCG',
        'NESTLEIND.NS': 'Nestle India - FMCG',
        'BRITANNIA.NS': 'Britannia Industries - FMCG',
        'DABUR.NS': 'Dabur India - FMCG',
        'GODREJCP.NS': 'Godrej Consumer Products - FMCG',
        'MARICO.NS': 'Marico - FMCG',
        'COLPAL.NS': 'Colgate Palmolive - FMCG',

        # Telecom
        'BHARTIARTL.NS': 'Bharti Airtel - Telecom',
        'IDEA.NS': 'Vodafone Idea - Telecom',

        # Power & Energy
        'NTPC.NS': 'NTPC - Power',
        'POWERGRID.NS': 'Power Grid Corporation - Power',
        'TATAPOWER.NS': 'Tata Power - Power',
        'ADANIENT.NS': 'Adani Enterprises - Power',
        'ADANIPORTS.NS': 'Adani Ports - Infrastructure',

        # Cement
        'ULTRACEMCO.NS': 'UltraTech Cement - Cement',
        'SHREECEM.NS': 'Shree Cement - Cement',
        'ACC.NS': 'ACC - Cement',
        'AMBUJACEM.NS': 'Ambuja Cements - Cement',

        # Consumer Durables
        'BAJAJFINSV.NS': 'Bajaj Finserv - Financial Services',
        'BAJFINANCE.NS': 'Bajaj Finance - Financial Services',
        'TITAN.NS': 'Titan Company - Consumer Goods',
        'ASIANPAINT.NS': 'Asian Paints - Paints',
        'BERGER.NS': 'Berger Paints - Paints',

        # Infrastructure
        'LT.NS': 'Larsen & Toubro - Infrastructure',
        'PFC.NS': 'Power Finance Corporation - Infrastructure',
        'RECLTD.NS': 'REC Limited - Infrastructure',

        # Aviation
        'SPICEJET.NS': 'SpiceJet - Aviation',
        'INDIGO.NS': 'IndiGo - Aviation',

        # Retail
        'DMART.NS': 'Avenue Supermarts (DMart) - Retail',
        'TRENT.NS': 'Trent - Retail',

        # Real Estate
        'DLF.NS': 'DLF - Real Estate',
        'GODREJPROP.NS': 'Godrej Properties - Real Estate',
        'OBEROIRLTY.NS': 'Oberoi Realty - Real Estate',

        # ETFs and Indices
        'NIFTYBEES.NS': 'Nippon India ETF Nifty BeES - ETF',
        'JUNIORBEES.NS': 'Nippon India ETF Junior BeES - ETF',
    }

    return indian_stocks

class SimpleStockPredictor:
    def __init__(self, ticker, years=5, interval='1d'):
        self.ticker = ticker
        self.years = years
        self.interval = interval
        self.start_date = (datetime.now() - timedelta(days=365 * years)).strftime('%Y-%m-%d')
        self.end_date = datetime.now().strftime('%Y-%m-%d')
        self.data = None
        self.features = None
        self.predictions = {}
        self.q_table = {}  # Q-table for RL
        self.learning_rate = 0.1
        self.discount_factor = 0.9
        self.epsilon = 0.1  # For epsilon-greedy exploration

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_exponential(multiplier=1, min=4, max=10),
        retry=retry_if_exception_type(Exception),
        reraise=True
    )
    def fetch_data(self):
        try:
            with st.spinner(f"Fetching data for {self.ticker}..."):
                self.data = yf.download(self.ticker, start=self.start_date, end=self.end_date,
                                      auto_adjust=True, progress=False)

                if self.data.empty or len(self.data) < 100:
                    raise ValueError(f"Insufficient data for {self.ticker}: {len(self.data)} periods fetched")

                st.success(f"‚úÖ Fetched {len(self.data)} periods of data")

                if isinstance(self.data.columns, pd.MultiIndex):
                    self.data.columns = [col[0] for col in self.data.columns]
                self.data = self.data[['Open', 'High', 'Low', 'Close', 'Volume']]
                return True

        except Exception as e:
            st.error(f"‚ùå Error fetching data: {e}")
            return False

    def engineer_features(self):
        if self.data is None or self.data.empty:
            st.error("Cannot engineer features: No data available")
            return False

        with st.spinner("Engineering features..."):
            df = self.data.copy()
            df['SMA_5'] = df['Close'].rolling(window=5, min_periods=1).mean()
            df['SMA_20'] = df['Close'].rolling(window=20, min_periods=1).mean()
            df['Trend'] = df['Close'].pct_change().rolling(window=2, min_periods=1).mean()
            self.features = df
            st.success(f"‚úÖ Engineered features with {len(df)} rows")
            return True

    def predict_next_day(self, trend_factor=0.5, use_rl=False):
        if self.features is None or self.features.empty:
            st.error("Cannot predict: No features available")
            return None

        self.predictions = {
            'Open': None,
            'High': None,
            'Low': None,
            'Close': None,
            'Date': None
        }

        latest_data = self.features.iloc[-1]
        last_time = self.data.index[-1]
        last_close = self.data['Close'].iloc[-1]
        last_return = self.data['Close'].pct_change().iloc[-1]

        # Calculate next trading day
        next_day = last_time.date() + timedelta(days=1)
        while next_day.weekday() >= 5:  # Skip weekends
            next_day += timedelta(days=1)

        # Create timezone-aware timestamp
        if hasattr(last_time, 'tz') and last_time.tz is not None:
            next_date = pd.Timestamp(next_day, tz=last_time.tz).replace(hour=9, minute=15)
        else:
            next_date = pd.Timestamp(next_day).replace(hour=9, minute=15)

        # RL: Choose trend_factor using epsilon-greedy
        state = f"{latest_data['SMA_5'] > latest_data['SMA_20']}_{last_return:.4f}"
        if use_rl and np.random.random() < self.epsilon:
            trend_factor = np.random.choice([0.3, 0.5, 0.7, 1.0])  # Exploration
        elif use_rl and state in self.q_table:
            best_action = max(self.q_table[state], key=self.q_table[state].get)
            trend_factor = best_action  # Exploitation

        # Moving Average Crossover Strategy
        sma_5 = latest_data['SMA_5']
        sma_20 = latest_data['SMA_20']
        trend = latest_data['Trend']

        if sma_5 > sma_20:
            base_pred = last_close * (1 + trend)
        else:
            base_pred = last_close * (1 + trend * trend_factor)

        volatility = self.data['Close'].tail(10).pct_change().std() * np.sqrt(252)
        daily_vol = volatility / np.sqrt(252)

        recent_opens = self.data['Open'].tail(5).mean()
        momentum = (base_pred - last_close) / last_close
        predicted_open = recent_opens * (1 + momentum * 0.3)
        predicted_close = base_pred
        predicted_high = predicted_close * (1 + daily_vol)
        predicted_low = predicted_close * (1 - daily_vol)

        # Apply price constraints
        min_price = last_close * 0.9
        max_price = last_close * 1.1

        predicted_open = max(min(predicted_open, max_price), min_price)
        predicted_high = max(min(predicted_high, max_price), min_price)
        predicted_low = max(min(predicted_low, max_price), min_price)
        predicted_close = max(min(predicted_close, max_price), min_price)

        # Ensure logical price relationships
        predicted_high = max(predicted_high, predicted_open, predicted_close)
        predicted_low = min(predicted_low, predicted_open, predicted_close)
        predicted_close = min(max(predicted_close, predicted_low), predicted_high)

        self.predictions['Open'] = predicted_open
        self.predictions['High'] = predicted_high
        self.predictions['Low'] = predicted_low
        self.predictions['Close'] = predicted_close
        self.predictions['Date'] = next_date

        return trend_factor

    def backtest(self, days=15):
        if self.data is None or len(self.data) < days + 20:
            st.error("Insufficient data for backtesting")
            return None

        with st.spinner(f"Running backtest for {days} days..."):
            backtest_results = []
            end_idx = len(self.data) - 1
            start_idx = end_idx - days

            progress_bar = st.progress(0)
            for idx, i in enumerate(range(start_idx, end_idx)):
                progress_bar.progress((idx + 1) / days)

                # Use data up to the day before the prediction day
                temp_data = self.data.iloc[:i]
                temp_features = self.features.iloc[:i]

                # Temporarily set data and features for prediction
                original_data = self.data
                original_features = self.features
                self.data = temp_data
                self.features = temp_features

                trend_factor = self.predict_next_day()
                pred = self.predictions
                actual = original_data.iloc[i]  # Actual prices for the prediction day

                # Restore original data and features
                self.data = original_data
                self.features = original_features

                mape = {
                    'Open': abs(pred['Open'] - actual['Open']) / actual['Open'] * 100,
                    'High': abs(pred['High'] - actual['High']) / actual['High'] * 100,
                    'Low': abs(pred['Low'] - actual['Low']) / actual['Low'] * 100,
                    'Close': abs(pred['Close'] - actual['Close']) / actual['Close'] * 100
                }
                backtest_results.append({
                    'Date': actual.name.date() if hasattr(actual.name, 'date') else actual.name,
                    'Actual_Open': actual['Open'],
                    'Pred_Open': pred['Open'],
                    'Actual_High': actual['High'],
                    'Pred_High': pred['High'],
                    'Actual_Low': actual['Low'],
                    'Pred_Low': pred['Low'],
                    'Actual_Close': actual['Close'],
                    'Pred_Close': pred['Close'],
                    'MAPE_Open': mape['Open'],
                    'MAPE_High': mape['High'],
                    'MAPE_Low': mape['Low'],
                    'MAPE_Close': mape['Close']
                })

            progress_bar.empty()
            results_df = pd.DataFrame(backtest_results)
            st.success("‚úÖ Backtesting completed!")
            return results_df

    def reinforcement_learning(self, days=15):
        if self.data is None or len(self.data) < days + 20:
            st.error("Insufficient data for reinforcement learning")
            return

        with st.spinner("Training Q-Learning model..."):
            end_idx = len(self.data) - 1
            start_idx = end_idx - days

            progress_bar = st.progress(0)
            for idx, i in enumerate(range(start_idx, end_idx)):
                progress_bar.progress((idx + 1) / days)

                temp_data = self.data.iloc[:i]
                temp_features = self.features.iloc[:i]
                original_data = self.data
                original_features = self.features
                self.data = temp_data
                self.features = temp_features

                state = f"{self.features.iloc[-1]['SMA_5'] > self.features.iloc[-1]['SMA_20']}_{self.data['Close'].pct_change().iloc[-1]:.4f}"
                if state not in self.q_table:
                    self.q_table[state] = {0.3: 0, 0.5: 0, 0.7: 0, 1.0: 0}

                trend_factor = self.predict_next_day(trend_factor=0.5, use_rl=True)
                pred = self.predictions
                actual = original_data.iloc[i]

                mape_close = abs(pred['Close'] - actual['Close']) / actual['Close'] * 100
                reward = 1.0 if mape_close <= 1.0 else -1.0

                # Compute next state
                self.data = original_data.iloc[:i+1]
                self.features = original_features.iloc[:i+1]
                next_state = f"{self.features.iloc[-1]['SMA_5'] > self.features.iloc[-1]['SMA_20']}_{self.data['Close'].pct_change().iloc[-1]:.4f}"
                if next_state not in self.q_table:
                    self.q_table[next_state] = {0.3: 0, 0.5: 0, 0.7: 0, 1.0: 0}

                max_future_q = max(self.q_table[next_state].values())
                self.q_table[state][trend_factor] += self.learning_rate * (
                    reward + self.discount_factor * max_future_q - self.q_table[state][trend_factor]
                )

                # Restore original data
                self.data = original_data
                self.features = original_features

            progress_bar.empty()
            st.success("‚úÖ Q-Learning training completed!")

# Title
st.markdown('<h1 class="main-header">üáÆüá≥ Indian Stock Price Predictor</h1>', unsafe_allow_html=True)
st.markdown("### Powered by Machine Learning & Reinforcement Learning")

# Get Indian stock tickers
indian_stocks = get_indian_stock_tickers()

# Sidebar for inputs
st.sidebar.header("üîß Configuration")
st.sidebar.markdown("---")

# Stock selection with search
st.sidebar.subheader("üìä Select Stock")

# Search functionality
search_term = st.sidebar.text_input("üîç Search stocks:", placeholder="Type to search...")

# Filter stocks based on search
if search_term:
    filtered_stocks = {k: v for k, v in indian_stocks.items()
                      if search_term.lower() in v.lower() or search_term.upper() in k}
else:
    filtered_stocks = indian_stocks

# Select stock
selected_display = st.sidebar.selectbox(
    "Choose a stock:",
    options=list(filtered_stocks.values()),
    index=list(filtered_stocks.values()).index('Reliance Industries - Oil & Gas') if 'RELIANCE.NS' in filtered_stocks else 0
)

# Get ticker from display name
ticker = [k for k, v in filtered_stocks.items() if v == selected_display][0]

# Manual ticker input option
st.sidebar.markdown("---")
manual_ticker = st.sidebar.text_input(
    "Or enter custom ticker:",
    placeholder="e.g., TATASTEEL.NS",
    help="Enter any NSE ticker symbol"
)

if manual_ticker:
    ticker = manual_ticker.upper()
    if not ticker.endswith('.NS'):
        ticker += '.NS'

# Other parameters
st.sidebar.markdown("---")
years = st.sidebar.slider(
    "Years of Historical Data",
    min_value=1,
    max_value=10,
    value=5,
    help="Number of years of historical data to use for training"
)

interval = st.sidebar.selectbox(
    "Data Interval",
    options=['1d', '1wk', '1mo'],
    index=0,
    help="Time interval for stock data"
)

backtest_days = st.sidebar.slider(
    "Backtest Days",
    min_value=5,
    max_value=30,
    value=15,
    help="Number of days to backtest the model"
)

use_rl = st.sidebar.checkbox(
    "Use Reinforcement Learning",
    value=True,
    help="Enable Q-Learning for enhanced predictions"
)

# Run prediction
if st.sidebar.button("üöÄ Run Prediction", type="primary"):
    predictor = SimpleStockPredictor(ticker, years, interval)

    if predictor.fetch_data() and predictor.engineer_features():
        # Display current stock info
        col1, col2, col3, col4 = st.columns(4)

        last_price = predictor.data['Close'].iloc[-1]
        prev_price = predictor.data['Close'].iloc[-2] if len(predictor.data) > 1 else last_price
        change = last_price - prev_price
        change_pct = (change / prev_price) * 100 if prev_price != 0 else 0

        with col1:
            st.metric(
                "Current Price",
                f"‚Çπ{last_price:.2f}",
                f"{change:.2f} ({change_pct:.2f}%)"
            )

        with col2:
            st.metric("Volume", f"{predictor.data['Volume'].iloc[-1]:,.0f}")

        with col3:
            st.metric("52W High", f"‚Çπ{predictor.data['High'].max():.2f}")

        with col4:
            st.metric("52W Low", f"‚Çπ{predictor.data['Low'].min():.2f}")

        # Run backtesting
        backtest_results = predictor.backtest(days=backtest_days)

        # Run reinforcement learning
        if use_rl:
            predictor.reinforcement_learning(days=backtest_days)

        # Make final prediction
        with st.spinner("Making final prediction..."):
            predictor.predict_next_day(use_rl=use_rl)

        # Display predictions
        st.markdown("## üéØ Tomorrow's Predictions")

        pred_col1, pred_col2, pred_col3, pred_col4 = st.columns(4)

        with pred_col1:
            st.markdown(f"""
            <div class="prediction-box">
                <h3>Open</h3>
                <h2>‚Çπ{predictor.predictions['Open']:.2f}</h2>
            </div>
            """, unsafe_allow_html=True)

        with pred_col2:
            st.markdown(f"""
            <div class="prediction-box">
                <h3>High</h3>
                <h2>‚Çπ{predictor.predictions['High']:.2f}</h2>
            </div>
            """, unsafe_allow_html=True)

        with pred_col3:
            st.markdown(f"""
            <div class="prediction-box">
                <h3>Low</h3>
                <h2>‚Çπ{predictor.predictions['Low']:.2f}</h2>
            </div>
            """, unsafe_allow_html=True)

        with pred_col4:
            st.markdown(f"""
            <div class="prediction-box">
                <h3>Close</h3>
                <h2>‚Çπ{predictor.predictions['Close']:.2f}</h2>
            </div>
            """, unsafe_allow_html=True)

        # Stock price chart
        st.markdown("## üìä Price Chart")

        fig = go.Figure()

        # Add candlestick chart
        chart_data = predictor.data.tail(100)  # Last 100 days
        fig.add_trace(go.Candlestick(
            x=chart_data.index,
            open=chart_data['Open'],
            high=chart_data['High'],
            low=chart_data['Low'],
            close=chart_data['Close'],
            name="Stock Price"
        ))

        # Add moving averages
        fig.add_trace(go.Scatter(
            x=predictor.features.tail(100).index,
            y=predictor.features.tail(100)['SMA_5'],
            mode='lines',
            name='SMA 5',
            line=dict(color='orange', width=1)
        ))

        fig.add_trace(go.Scatter(
            x=predictor.features.tail(100).index,
            y=predictor.features.tail(100)['SMA_20'],
            mode='lines',
            name='SMA 20',
            line=dict(color='blue', width=1)
        ))

        fig.update_layout(
            title=f"{ticker} Stock Price (Last 100 Days)",
            yaxis_title="Price (‚Çπ)",
            xaxis_title="Date",
            template="plotly_white",
            height=600,
            xaxis_rangeslider_visible=False
        )

        st.plotly_chart(fig, use_container_width=True)

        # Backtest results
        if backtest_results is not None:
            st.markdown("## üìà Model Performance")

            # Calculate metrics
            avg_mape = backtest_results[['MAPE_Open', 'MAPE_High', 'MAPE_Low', 'MAPE_Close']].mean().mean()
            close_mape = backtest_results['MAPE_Close'].mean()
            rmse = np.sqrt(np.mean((backtest_results['Actual_Close'] - backtest_results['Pred_Close'])**2))

            col1, col2, col3 = st.columns(3)
            with col1:
                st.metric("Average MAPE", f"{avg_mape:.2f}%")
            with col2:
                st.metric("Close MAPE", f"{close_mape:.2f}%")
            with col3:
                st.metric("RMSE", f"‚Çπ{rmse:.2f}")

            # Backtest chart
            fig2 = go.Figure()

            fig2.add_trace(go.Scatter(
                x=backtest_results['Date'],
                y=backtest_results['Actual_Close'],
                mode='lines+markers',
                name='Actual Close',
                line=dict(color='blue', width=2)
            ))

            fig2.add_trace(go.Scatter(
                x=backtest_results['Date'],
                y=backtest_results['Pred_Close'],
                mode='lines+markers',
                name='Predicted Close',
                line=dict(color='red', width=2, dash='dash')
            ))

            fig2.update_layout(
                title="Backtest Results: Actual vs Predicted Close Prices",
                yaxis_title="Price (‚Çπ)",
                xaxis_title="Date",
                template="plotly_white",
                height=400
            )

            st.plotly_chart(fig2, use_container_width=True)

            # Show backtest table
            st.markdown("### üìã Detailed Backtest Results")
            st.dataframe(backtest_results.round(2), use_container_width=True)

        # Q-Table display
        if use_rl and predictor.q_table:
            st.markdown("## üß† Q-Learning Results")
            q_table_df = pd.DataFrame.from_dict(predictor.q_table, orient='index')
            st.dataframe(q_table_df.round(3), use_container_width=True)

        # Model info
        st.markdown("## ‚ÑπÔ∏è Model Information")

        model_info = f"""
        **Configuration:**
        - Stock Symbol: {ticker}
        - Training Period: {years} years
        - Data Interval: {interval}
        - Backtest Period: {backtest_days} days
        - Reinforcement Learning: {'Enabled' if use_rl else 'Disabled'}

        **Features Used:**
        - OHLCV (Open, High, Low, Close, Volume)
        - Simple Moving Averages (5-day, 20-day)
        - Price Trends and Momentum
        - Volatility Calculations
        - Technical Indicators

        **Algorithm:**
        - Moving Average Crossover Strategy
        - Volatility-based Price Bounds
        - Q-Learning for Parameter Optimization
        - Price Relationship Constraints

        **Disclaimer:**
        ‚ö†Ô∏è This is for educational purposes only. Not financial advice.
        Always consult with a financial advisor before making investment decisions.
        """

        st.markdown(model_info)

        # Download predictions
        if st.button("üíæ Download Predictions"):
            predictions_data = {
                'Date': [predictor.predictions['Date'].strftime('%Y-%m-%d') if predictor.predictions['Date'] else 'N/A'],
                'Predicted_Open': [predictor.predictions['Open']],
                'Predicted_High': [predictor.predictions['High']],
                'Predicted_Low': [predictor.predictions['Low']],
                'Predicted_Close': [predictor.predictions['Close']],
                'Current_Price': [last_price],
                'Symbol': [ticker]
            }

            predictions_df = pd.DataFrame(predictions_data)

            # Convert to CSV
            csv_buffer = io.StringIO()
            predictions_df.to_csv(csv_buffer, index=False)
            csv_data = csv_buffer.getvalue()

            st.download_button(
                label="üì• Download as CSV",
                data=csv_data,
                file_name=f"{ticker}_predictions_{datetime.now().strftime('%Y%m%d')}.csv",
                mime="text/csv"
            )

# Footer
st.markdown("---")
st.markdown("""
<div style="text-align: center; color: #666; padding: 20px;">
    <p>üî¨ Built with Python, Streamlit, and Machine Learning</p>
    <p>üìä Data powered by Yahoo Finance</p>
    <p>‚ö° Enhanced with Reinforcement Learning</p>
</div>
""", unsafe_allow_html=True)

# Sidebar info
st.sidebar.markdown("---")
st.sidebar.markdown("### üìù About")
st.sidebar.info("""
This app uses machine learning to predict Indian stock prices.

**Features:**
- üìà Next-day OHLC predictions
- üß† Q-Learning optimization
- üìä Backtesting validation
- üéØ Technical indicators
- üì± Mobile-friendly interface

**Data Source:** Yahoo Finance
""")

st.sidebar.markdown("### ‚ö†Ô∏è Disclaimer")
st.sidebar.warning("""
**Not Financial Advice**

This tool is for educational and research purposes only. Stock predictions are inherently uncertain. Always do your own research and consult with financial professionals before making investment decisions.
""")

# Error handling for the main app
if __name__ == "__main__":
    try:
        # Main app logic is already above
        pass
    except Exception as e:
        st.error(f"Application Error: {str(e)}")
        st.info("Please refresh the page or try again later.")